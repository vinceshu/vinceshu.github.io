<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vinceshu.cn/"/>
  <updated>2020-07-26T13:38:42.775Z</updated>
  <id>http://vinceshu.cn/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的第一篇在阿里云上部署的hexo博文</title>
    <link href="http://vinceshu.cn/2020/07/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%9A%84hexo%E5%8D%9A%E6%96%87/"/>
    <id>http://vinceshu.cn/2020/07/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%9A%84hexo%E5%8D%9A%E6%96%87/</id>
    <published>2020-07-26T13:38:42.000Z</published>
    <updated>2020-07-26T13:38:42.775Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>1、单元测试&amp;反射&amp;注解</title>
    <link href="http://vinceshu.cn/2020/07/26/1%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&amp;%E5%8F%8D%E5%B0%84&amp;%E6%B3%A8%E8%A7%A3/"/>
    <id>http://vinceshu.cn/2020/07/26/1%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&amp;%E5%8F%8D%E5%B0%84&amp;%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-07-26T09:48:35.172Z</published>
    <updated>2020-07-26T09:49:24.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="junit单元测试"><a class="markdownIt-Anchor" href="#junit单元测试"></a> Junit单元测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* 测试分类：</span><br><span class="line"><span class="number">1</span>. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</span><br><span class="line"><span class="number">2</span>. 白盒测试：需要写代码的。关注程序具体的执行流程。</span><br><span class="line"></span><br><span class="line">* Junit使用：白盒测试</span><br><span class="line">* 步骤：</span><br><span class="line"><span class="number">1</span>. 定义一个测试类(测试用例)</span><br><span class="line">* 建议：</span><br><span class="line">* 测试类名：被测试的类名TestCalculatorTest</span><br><span class="line">* 包名：xxx.xxx.xx.testcn.itcast.test</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 定义测试方法：可以独立运行</span><br><span class="line">* 建议：</span><br><span class="line">* 方法名：test测试的方法名testAdd()  </span><br><span class="line">* 返回值：<span class="keyword">void</span></span><br><span class="line">* 参数列表：空参</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 给方法加<span class="meta">@Test</span></span><br><span class="line"><span class="number">4</span>. 导入junit依赖环境</span><br><span class="line"></span><br><span class="line">* 判定结果：</span><br><span class="line">* 红色：失败</span><br><span class="line">* 绿色：成功</span><br><span class="line">* 一般我们会使用断言操作来处理结果</span><br><span class="line">* Assert.assertEquals(期望的结果,运算的结果);</span><br><span class="line"></span><br><span class="line">* 补充：</span><br><span class="line">* <span class="meta">@Before</span>:</span><br><span class="line">* 修饰的方法会在测试方法之前被自动执行</span><br><span class="line">* <span class="meta">@After</span>:</span><br><span class="line">* 修饰的方法会在测试方法执行之后自动被执行</span><br></pre></td></tr></table></figure><h2 id="反射框架设计的灵魂"><a class="markdownIt-Anchor" href="#反射框架设计的灵魂"></a> 反射：框架设计的灵魂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</span><br><span class="line">字节码文件里面放了：成员变量、、成员方法、构造方法</span><br><span class="line">* 反射：将类的各个组成部分封装为其他对象，这就是反射机制</span><br><span class="line">* 好处：</span><br><span class="line"><span class="number">1</span>. 可以在程序运行过程中，操作这些对象。</span><br><span class="line"><span class="number">2</span>. 可以解耦，提高程序的可扩展性。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">*Java反射机制提供的功能</span><br><span class="line">-在运行时判断任意一个对象所属的类</span><br><span class="line">-在运行时构造任意一个类的对象</span><br><span class="line">-在运行时判断任意一个类所具有的成员变量和方法</span><br><span class="line">-在运行时获取泛型信息</span><br><span class="line">-在运行时调用任意一个对象的成员变量和方法</span><br><span class="line">-在运行时处理注解</span><br><span class="line">-生成动态代理</span><br><span class="line">*主要API</span><br><span class="line">-java.lang.Class：代表一个类</span><br><span class="line">    -java.lang.reflect.Nethod：代表类的方法</span><br><span class="line">-java.lang.reflect.Field：代表类的成员变量</span><br><span class="line">-java.lang.reflect.Constructor：代表类的构造器</span><br><span class="line"></span><br><span class="line">#关于java.lang.Class类的理解：</span><br><span class="line"><span class="number">1</span>、类加载的过程---Java万事万物皆对象</span><br><span class="line">当程序经过javac.exe(编译)命令后，会生成一个或多个字节码文件(<span class="class">.<span class="keyword">class</span>文件)，接着我们使用<span class="title">java</span>.<span class="title">exe</span>(解释命令)对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载。加载到内存中的类我们就称为运行时类，此运行时类就作为<span class="title">Class</span>类的一个实例化对象。<span class="title">Class</span> <span class="title">clazz</span> </span>= Person<span class="class">.<span class="keyword">class</span> </span></span><br><span class="line"><span class="class">2、换句话说，一个<span class="title">Class</span>的实例化对象就对应着一个运行时类</span></span><br><span class="line"><span class="class">3、加载到内存中的运行时类，会在缓存区缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类</span></span><br><span class="line"><span class="class">4、哪些类型可以有<span class="title">Class</span>对象？</span></span><br><span class="line"><span class="class">1、<span class="title">class</span>：外部类、成员内部类、静态内部类、局部内部类、匿名内部类</span></span><br><span class="line"><span class="class">2、<span class="title">interface</span>：接口</span></span><br><span class="line">3、[]：数组</span><br><span class="line"><span class="number">4</span>、<span class="keyword">enum</span>：枚举</span><br><span class="line"><span class="number">5</span>、annotation：注解<span class="meta">@interface</span></span><br><span class="line"><span class="number">6</span>、primitive type：基本数据类型</span><br><span class="line"><span class="number">7</span>、<span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">#类的加载过程：了解</span><br><span class="line">当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤对该类进行初始化</span><br><span class="line"><span class="number">1</span>、类的加载(Load)：将类的<span class="class"><span class="keyword">class</span>文件读入内存，并为之创建一个<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>对象，此过程由类加载器完成</span></span><br><span class="line"><span class="class">---加载：将<span class="title">class</span>文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个<span class="title">Class</span>对象。这个加载的过程需要类加载器参与。</span></span><br><span class="line"><span class="class">2、类的链接(<span class="title">Link</span>)：将类的二进制数据合并到<span class="title">JRE</span>中</span></span><br><span class="line"><span class="class">---链接：将<span class="title">Java</span>类的二进制代码合并到<span class="title">JVM</span>的运行状态之中的过程。</span></span><br><span class="line"><span class="class">    *验证：确保加载的类信息符合<span class="title">JVM</span>规范，例如：以<span class="title">cafe</span>开头，没有安全方面的问题</span></span><br><span class="line"><span class="class">    *准备：正式为类变量（<span class="title">static</span>）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</span></span><br><span class="line"><span class="class">    *解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</span></span><br><span class="line"><span class="class">3、类的初始化(<span class="title">Initialize</span>)：<span class="title">JVM</span>负责对类进行初始化</span></span><br><span class="line"><span class="class">*执行类构造器&lt;<span class="title">clinit</span>&gt;()方法的过程。类构造器&lt;<span class="title">clinit</span>&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</span></span><br><span class="line"><span class="class">    *当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。</span></span><br><span class="line"><span class="class">    *虚拟机会保证一个类的&lt;<span class="title">clinit</span>&gt;()方法在多线程环境中被正确加锁和同步。</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    #类加载器</span></span><br><span class="line"><span class="class">    类加载器的作用：</span></span><br><span class="line"><span class="class">        *类加载的作用：将<span class="title">class</span>文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>对象，作为方法区中类数据的访问入口。</span></span><br><span class="line"><span class="class">        *类缓存：标准的<span class="title">JavaSE</span>类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过<span class="title">JVM</span>垃圾回收机制可以回收这些<span class="title">Class</span>对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* 获取Class对象的方式：-----当加载类时会自动创建反射对象，以下是获得反射对象的三种方式</span><br><span class="line"><span class="number">1</span>. Class.forName(<span class="string">"全类名"</span>)：将字节码文件加载进内存，返回Class对象</span><br><span class="line">------source源代码阶段，即编译阶段</span><br><span class="line">* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类</span><br><span class="line"><span class="number">2</span>. 类名<span class="class">.<span class="keyword">class</span>：通过类名的属性<span class="title">class</span>获取</span></span><br><span class="line"><span class="class">------<span class="title">Class</span>类对象阶段，即使用类加载器加载字节码文件成为<span class="title">Class</span>类对象阶段</span></span><br><span class="line"><span class="class">* 多用于参数的传递</span></span><br><span class="line"><span class="class">3. 对象.<span class="title">getClass</span>()：<span class="title">getClass</span>()方法在<span class="title">Object</span>类中定义着。</span></span><br><span class="line"><span class="class">------运行时阶段，即开辟内存空间开始调用<span class="title">main</span>方法阶段</span></span><br><span class="line"><span class="class">* 多用于对象的获取字节码的方式</span></span><br><span class="line"><span class="class">4. <span class="title">ClassLoader</span> <span class="title">classLoader</span> </span>= Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">   Class clazz = classLoader.loadClass(<span class="string">"全类名"</span>);</span><br><span class="line">    *通过类加载器的方式获取Class对象（了解）</span><br><span class="line">    </span><br><span class="line">* 结论：</span><br><span class="line">同一个字节码文件(*<span class="class">.<span class="keyword">class</span>)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的<span class="title">Class</span>对象都是同一个。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* Class对象功能：</span><br><span class="line">* 获取功能：获取当前运行时类中的东西</span><br><span class="line"><span class="number">1</span>. 获取成员变量们</span><br><span class="line">* Field[] getFields()  获取所有<span class="keyword">public</span>修饰的成员变量</span><br><span class="line">* <span class="function">Field <span class="title">getField</span><span class="params">(String name)</span>  获取指定名称的<span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* Field[] <span class="title">getDeclaredFields</span><span class="params">()</span>  获取所有的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function">* Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function">2. 获取构造方法们</span></span><br><span class="line"><span class="function">* Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">* Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function">* Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">3. 获取成员方法们：</span></span><br><span class="line"><span class="function">* Method[] <span class="title">getMethods</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">* Method <span class="title">getMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">* Method <span class="title">getDeclaredMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function">4. 获取全类名</span></span><br><span class="line"><span class="function">* String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* Field：成员变量</span><br><span class="line">* 操作：</span><br><span class="line"><span class="number">1</span>. 设置值</span><br><span class="line">* <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span>  参数1：哪个对象的属性 参数2：属性值</span></span><br><span class="line"><span class="function">2. 获取值</span></span><br><span class="line"><span class="function">* <span class="title">get</span><span class="params">(Object obj)</span> 参数1：获取哪个对象的属性值</span></span><br><span class="line"><span class="function">3. 忽略访问权限修饰符的安全检查</span></span><br><span class="line"><span class="function">* <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span>:暴力反射</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* Method：方法对象</span></span><br><span class="line"><span class="function">* 执行方法：</span></span><br><span class="line"><span class="function">* Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span>  参数1：方法的调用者 参数2：给方法的形参赋值</span></span><br><span class="line"><span class="function">* 获取方法名称：</span></span><br><span class="line"><span class="function">* String getName:获取方法名</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* Constructor:构造方法---只有构造器才能获取对象</span><br><span class="line">* 创建对象：</span><br><span class="line">* <span class="function">T <span class="title">newInstance</span><span class="params">(Object... initargs)</span>  参数：指明构造器的参数列表 </span></span><br><span class="line"><span class="function">* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span></span><br></pre></td></tr></table></figure><h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* 概念：说明程序的。给计算机看的</span><br><span class="line">* 注释：用文字描述程序的。给程序员看的</span><br><span class="line"></span><br><span class="line">* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1<span class="number">.5</span>及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</span><br><span class="line">* 概念描述：</span><br><span class="line">* JDK1<span class="number">.5</span>之后的新特性</span><br><span class="line">* 说明程序的</span><br><span class="line">* 使用注解：@注解名称</span><br><span class="line">* 作用分类：</span><br><span class="line">    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</span><br><span class="line">    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】</span><br><span class="line">    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">* JDK中预定义的一些注解</span><br><span class="line">* <span class="meta">@Override</span>：检测被该注解标注的方法是否是继承自父类(接口)的</span><br><span class="line">* <span class="meta">@Deprecated</span>：该注解标注的内容，表示已过时</span><br><span class="line">* <span class="meta">@SuppressWarnings</span>：压制警告</span><br><span class="line">* 一般传递参数all  <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"></span><br><span class="line">* 自定义注解</span><br><span class="line">* 格式：</span><br><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">属性列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口</span><br><span class="line">* <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnno</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">* 属性：接口中的抽象方法</span><br><span class="line">* 要求：</span><br><span class="line"><span class="number">1</span>. 属性的返回值类型有下列取值</span><br><span class="line">* 基本数据类型</span><br><span class="line">* String</span><br><span class="line">* 枚举</span><br><span class="line">* 注解</span><br><span class="line">* 以上类型的数组</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 定义了属性，在使用时需要给属性赋值</span><br><span class="line"><span class="number">1</span>. 如果定义属性时，使用<span class="keyword">default</span>关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</span><br><span class="line"><span class="number">2</span>. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</span><br><span class="line"><span class="number">3</span>. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略</span><br><span class="line"></span><br><span class="line">* 元注解：用于描述注解的注解</span><br><span class="line">* <span class="meta">@Target</span>：描述注解能够作用的位置</span><br><span class="line">* ElementType取值：</span><br><span class="line">* TYPE：可以作用于类上</span><br><span class="line">* METHOD：可以作用于方法上</span><br><span class="line">* FIELD：可以作用于成员变量上</span><br><span class="line">* <span class="meta">@Retention</span>：描述注解被保留的阶段</span><br><span class="line">* <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到<span class="class"><span class="keyword">class</span>字节码文件中，并被<span class="title">JVM</span>读取到</span></span><br><span class="line"><span class="class">* @<span class="title">Documented</span>：描述注解是否被抽取到<span class="title">api</span>文档中</span></span><br><span class="line"><span class="class">* @<span class="title">Inherited</span>：描述注解是否被子类继承</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 在程序使用(解析)注解：获取注解中定义的属性值</span><br><span class="line"><span class="number">1</span>. 获取注解定义的位置的对象  （Class，Method,Field）</span><br><span class="line"><span class="number">2</span>. 获取指定的注解</span><br><span class="line">* getAnnotation(Class)</span><br><span class="line"><span class="comment">//其实就是在内存中生成了一个该注解接口的子类实现对象</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProImpl</span> <span class="keyword">implements</span> <span class="title">Pro</span></span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">className</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"cn.itcast.annotation.Demo1"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">methodName</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="number">3</span>. 调用注解中的抽象方法获取配置的属性值</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 小结：</span><br><span class="line"><span class="number">1</span>. 以后大多数时候，我们会使用注解，而不是自定义注解</span><br><span class="line"><span class="number">2</span>. 注解给谁用？</span><br><span class="line"><span class="number">1</span>. 编译器</span><br><span class="line"><span class="number">2</span>. 给解析程序用</span><br><span class="line"><span class="number">3</span>. 注解不是程序的一部分，可以理解为注解就是一个标签</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;junit单元测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#junit单元测试&quot;&gt;&lt;/a&gt; Junit单元测试&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java基础-第二天</title>
    <link href="http://vinceshu.cn/2020/07/24/java-two/"/>
    <id>http://vinceshu.cn/2020/07/24/java-two/</id>
    <published>2020-07-24T14:54:02.696Z</published>
    <updated>2020-07-24T11:27:17.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1jvmjrejdk的作用与区别"><a class="markdownIt-Anchor" href="#1jvmjrejdk的作用与区别"></a> 1，JVM,JRE,JDK的作用与区别；</h3><p>jvm也就是我们常说的虚拟机，他是java跨平台的的核心部分，java源程序可以编译为class文件，可以在java虚拟机上执行，所以说java是通过虚拟机与操作系统交互。</p><p>JRE是java runtime enviroment运行时环境，他包括jvm虚拟机，库函数，还有一些运行程序必需的文件</p><p>JDK是java开发工具包，包含jre，以及增加编译器和调试器等程序开发文件。</p><h3 id="2java中8种基本数据类型有哪些它们占用的字节数分别是多少"><a class="markdownIt-Anchor" href="#2java中8种基本数据类型有哪些它们占用的字节数分别是多少"></a> 2，Java中8种基本数据类型有哪些，它们占用的字节数分别是多少；</h3><table><thead><tr><th>int</th><th>4</th></tr></thead><tbody><tr><td>short</td><td>2</td></tr><tr><td>long</td><td>8</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>char</td><td>2</td></tr><tr><td>double</td><td>8</td></tr><tr><td>float</td><td>4</td></tr><tr><td>boolean</td><td>1或4</td></tr></tbody></table><h3 id="3接口与抽象类的区别"><a class="markdownIt-Anchor" href="#3接口与抽象类的区别"></a> 3，接口与抽象类的区别；</h3><p>不同点：</p><p>1，接口是对类的行为的抽象，抽象类是对一些类的共有属性的抽取。</p><p>2，接口是用interface定义，抽象类是用abstract定义</p><p>3，接口没有构造方法，抽象方法可以有构造方法</p><p>4，接口可以通过多实现来实现多继承，抽象类只能单继承</p><p>相同点：</p><p>1，他们不能创建对象，他们只能通过继承或实现他们的类来实例化</p><p>2，继承和实现了他们的类必须实现他们的抽象方法</p><h3 id="4创建线程有几种方法它们的优缺点分别是什么"><a class="markdownIt-Anchor" href="#4创建线程有几种方法它们的优缺点分别是什么"></a> 4，创建线程有几种方法，它们的优缺点分别是什么；</h3><p>1.继承Thread类 2.实现Runnable接口</p><p>3.实现Callable接口 4.线程池方式</p><p>优缺点</p><p>1.继承Thread类</p><p>优点 、代码简单 。 缺点 、该类无法继承别的类。</p><p>2.实现Runnable接口</p><p>优点 、继承其他类。 同一实现该接口的实例可以共享资源。</p><p>缺点 、代码复杂，不能抛出异常</p><p>3.实现Callable</p><p>优点 、可以获得异步任务的返回值</p><p>4.线程池 、实现自动化装配，易于管理，循环利用资源。</p><h3 id="5加载类的方式有哪些"><a class="markdownIt-Anchor" href="#5加载类的方式有哪些"></a> 5，.加载类的方式有哪些；</h3><p>类加载分为静态加载和动态加载，动态加载就是从外储存器加载类，静态加载本质上是从内存中创建类的实例对象，此时类已经被加载到内存中。</p><p>1，由new关键字创建</p><p>2，Class.forName(全限定性类名)</p><p>3，ClassLoader.LoadClass(“类名”)</p><p>第一种是静态加载，后两种是动态加载</p><p>前两种是用当前类加载器，后一种是自定义类加载器</p><h3 id="6classforname加载类与classloader加载类有什么区别"><a class="markdownIt-Anchor" href="#6classforname加载类与classloader加载类有什么区别"></a> 6，class.forName加载类与classloader加载类有什么区别；</h3><p>Class的装载包括3个步骤：加载（loading）,连接（link）,初始化（initialize）.<br>Class.forName(className)实际上是调用Class.forName(className, true, this.getClass().getClassLoader())。第二个参数，是指Class被loading后是不是必须被初始化，也就是静态属性，代码块的执行。<br>ClassLoader.loadClass(className)实际上调用的是ClassLoader.loadClass(name, false)，第二个参数指Class是否被link。<br>Class.forName(className)装载的class已经被初始化，而ClassLoader.loadClass(className)装载的class还没有被link。一般情况下，这两个方法效果一样，都能装载Class。但如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。</p><h4 id="7说一下进程与线程的区别"><a class="markdownIt-Anchor" href="#7说一下进程与线程的区别"></a> 7，说一下进程与线程的区别；</h4><p>1，进程是资源分配的最小单位，线程是程序执行的最小单位</p><p>2，进程有独立的代码和数据空间，进程切换会有较大的开销，同一类线程有共同的代码和数据空间，线程切换开销不大。</p><p>3，系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存</p><p>4，在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p>5，一个程序至少有一个进程；一个进程至少有一个线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1jvmjrejdk的作用与区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1jvmjrejdk的作用与区别&quot;&gt;&lt;/a&gt; 1，JVM,JRE,JDK的作用与区别；&lt;/h3&gt;&lt;p&gt;jvm也就是我们常说的虚拟机，他是java跨平台的的核
      
    
    </summary>
    
    
      <category term="java" scheme="http://vinceshu.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://vinceshu.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础-第一天</title>
    <link href="http://vinceshu.cn/2020/07/21/java-one/"/>
    <id>http://vinceshu.cn/2020/07/21/java-one/</id>
    <published>2020-07-21T08:56:18.000Z</published>
    <updated>2020-07-24T11:27:13.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="语言特性-12"><a class="markdownIt-Anchor" href="#语言特性-12"></a> 语言特性 12</h3><h4 id="q1java-语言的优点"><a class="markdownIt-Anchor" href="#q1java-语言的优点"></a> Q1：Java 语言的优点？</h4><p>① 平台无关性，摆脱硬件束缚，“一次编写，到处运行”。</p><p>② 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。</p><p>③ 热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能。</p><p>④ 完善的应用程序接口，支持第三方类库。</p><hr><h4 id="q2java-如何实现平台无关"><a class="markdownIt-Anchor" href="#q2java-如何实现平台无关"></a> Q2：Java 如何实现平台无关？</h4><p><strong>JVM：</strong> Java 编译器可生成与计算机体系结构无关的字节码指令，字节码文件不仅可以轻易地在任何机器上解释执行，还可以动态地转换成本地机器代码，转换是由 JVM 实现的，JVM 是平台相关的，屏蔽了不同操作系统的差异。</p><p><strong>语言规范：</strong> 基本数据类型大小有明确规定，例如 int 永远为 32 位，而 C/C++ 中可能是 16 位、32 位，也可能是编译器开发商指定的其他大小。Java 中数值类型有固定字节数，二进制数据以固定格式存储和传输，字符串采用标准的 Unicode 格式存储。</p><hr><h4 id="q3jdk-和-jre-的区别"><a class="markdownIt-Anchor" href="#q3jdk-和-jre-的区别"></a> Q3：JDK 和 JRE 的区别？</h4><p><strong>JDK：</strong> Java Development Kit，开发工具包。提供了编译运行 Java 程序的各种工具，包括编译器、JRE 及常用类库，是 JAVA 核心。</p><p><strong>JRE：</strong> Java Runtime Environment，运行时环境，运行 Java 程序的必要环境，包括 JVM、核心类库、核心配置工具。</p><hr><h4 id="q4java-按值调用还是引用调用"><a class="markdownIt-Anchor" href="#q4java-按值调用还是引用调用"></a> Q4：Java 按值调用还是引用调用？</h4><p><strong>按值调用</strong>指方法接收调用者提供的值，<strong>按引用调用</strong>指方法接收调用者提供的变量地址。</p><p>Java 总是按值调用，方法得到的是所有参数值的副本，传递对象时实际上方法接收的是对象引用的副本。方法不能修改基本数据类型的参数，如果传递了一个 int 值 ，改变值不会影响实参，因为改变的是值的一个副本。</p><p>可以改变对象参数的状态，但不能让对象参数引用一个新的对象。如果传递了一个 int 数组，改变数组的内容会影响实参，而改变这个参数的引用并不会让实参引用新的数组对象。</p><hr><h4 id="q5浅拷贝和深拷贝的区别"><a class="markdownIt-Anchor" href="#q5浅拷贝和深拷贝的区别"></a> Q5：浅拷贝和深拷贝的区别？</h4><p><strong>浅拷贝：</strong> 只复制当前对象的基本数据类型及引用变量，没有复制引用变量指向的实际对象。修改克隆对象可能影响原对象，不安全。</p><p><strong>深拷贝：</strong> 完全拷贝基本数据类型和引用数据类型，安全。</p><hr><h4 id="q6什么是反射"><a class="markdownIt-Anchor" href="#q6什么是反射"></a> Q6：什么是反射？</h4><p>在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任意一个对象都能调用它的任意方法和属性，这种动态获取信息及调用对象方法的功能称为反射。缺点是破坏了封装性以及泛型约束。反射是框架的核心，Spring 大量使用反射。</p><hr><h4 id="q7class-类的作用如何获取一个-class-对象"><a class="markdownIt-Anchor" href="#q7class-类的作用如何获取一个-class-对象"></a> Q7：Class 类的作用？如何获取一个 Class 对象？</h4><p>在程序运行期间，Java 运行时系统为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是 Class，这是一个泛型类。</p><p>简单来说就是Class是一个保存了运行时信息的一个类，运行信息可以知道每个对象属于哪个类，jvm利用运行时信息选择相应的方法执行。</p><p>获取 Class 对象：① <code>类名.class</code> 。②对象的 <code>getClass</code>方法。③ <code>Class.forName(类的全限定名)</code>。</p><hr><h4 id="q8什么是注解什么是元注解"><a class="markdownIt-Anchor" href="#q8什么是注解什么是元注解"></a> Q8：什么是注解？什么是元注解？</h4><p><strong>注解</strong>是一种标记，使类或接口附加额外信息，帮助编译器和 JVM 完成一些特定功能，例如 <code>@Override</code> 标识一个方法是重写方法。</p><p><strong>元注解</strong>是自定义注解的注解，例如：</p><p><code>@Target</code>：约束作用位置，值是 ElementType 枚举常量，包括 METHOD 方法、VARIABLE 变量、TYPE 类/接口、PARAMETER 方法参数、CONSTRUCTORS 构造方法和 LOACL_VARIABLE 局部变量等。</p><p><code>@Rentention</code>：约束生命周期，值是 RetentionPolicy 枚举常量，包括 SOURCE 源码、CLASS 字节码和 RUNTIME 运行时。</p><p><code>@Documented</code>：表明这个注解应该被 javadoc 记录。</p><hr><h4 id="q9什么是泛型有什么作用"><a class="markdownIt-Anchor" href="#q9什么是泛型有什么作用"></a> Q9：什么是泛型，有什么作用？</h4><p><strong>泛型</strong>本质是参数化类型，解决不确定对象具体类型的问题。泛型在定义处只具备执行 Object 方法的能力。</p><p>泛型的好处：① 类型安全，放置什么出来就是什么，不存在 ClassCastException。② 提升可读性，编码阶段就显式知道泛型集合、泛型方法等处理的对象类型。③ 代码重用，合并了同类型的处理代码。</p><h4 id="q10泛型擦除是什么"><a class="markdownIt-Anchor" href="#q10泛型擦除是什么"></a> Q10：泛型擦除是什么？</h4><p>泛型用于编译阶段，编译后的字节码文件不包含泛型类型信息，因为虚拟机没有泛型类型对象，所有对象都属于普通类。例如定义 <code>List</code> 或 <code>List</code>，在编译后都会变成 <code>List</code> 。</p><p>定义一个泛型类型，会自动提供一个对应原始类型，类型变量会被擦除。如果没有限定类型就会替换为 Object，如果有限定类型就会替换为第一个限定类型，例如 `` 会使用 A 类型替换 T。</p><hr><h4 id="q11jdk8-新特性有哪些"><a class="markdownIt-Anchor" href="#q11jdk8-新特性有哪些"></a> Q11：JDK8 新特性有哪些？</h4><p>**lambda 表达式：**允许把函数作为参数传递到方法，简化匿名内部类代码。</p><p>**函数式接口：**使用 <code>@FunctionalInterface</code> 标识，有且仅有一个抽象方法，可被隐式转换为 lambda 表达式。</p><p>**方法引用：**可以引用已有类或对象的方法和构造方法，进一步简化 lambda 表达式。</p><p>**接口：**接口可以定义 <code>default</code> 修饰的默认方法，降低了接口升级的复杂性，还可以定义静态方法。</p><p>**注解：**引入重复注解机制，相同注解在同地方可以声明多次。注解作用范围也进行了扩展，可作用于局部变量、泛型、方法异常等。</p><p>**类型推测：**加强了类型推测机制，使代码更加简洁。</p><p>**Optional 类：**处理空指针异常，提高代码可读性。</p><p>**Stream 类：**引入函数式编程风格，提供了很多功能，使代码更加简洁。方法包括 <code>forEach</code> 遍历、<code>count</code> 统计个数、<code>filter</code> 按条件过滤、<code>limit</code> 取前 n 个元素、<code>skip</code> 跳过前 n 个元素、<code>map</code> 映射加工、<code>concat</code> 合并 stream 流等。</p><p>**日期：**增强了日期和时间 API，新的 java.time 包主要包含了处理日期、时间、日期/时间、时区、时刻和时钟等操作。</p><p>**JavaScript：**提供了一个新的 JavaScript 引擎，允许在 JVM上运行特定 JavaScript 应用。</p><hr><h4 id="q12异常有哪些分类"><a class="markdownIt-Anchor" href="#q12异常有哪些分类"></a> Q12：异常有哪些分类？</h4><p>所有异常都是 Throwable 的子类，分为 Error 和 Exception。<strong>Error</strong> 是 Java 运行时系统的内部错误和资源耗尽错误，例如 StackOverFlowError 和 OutOfMemoryError，这种异常程序无法处理。</p><p><strong>Exception</strong> 分为受检异常和非受检异常，受检异常需要在代码中显式处理，否则会编译出错，非受检异常是运行时异常，继承自 RuntimeException。</p><p><strong>受检异常</strong>：① 无能为力型，如字段超长导致的 SQLException。② 力所能及型，如未授权异常 UnAuthorizedException，程序可跳转权限申请页面。常见受检异常还有 FileNotFoundException、ClassNotFoundException、IOException等。</p><p><strong>非受检异常</strong>：① 可预测异常，例如 IndexOutOfBoundsException、NullPointerException、ClassCastException 等，这类异常应该提前处理。② 需捕捉异常，例如进行 RPC 调用时的远程服务超时，这类异常客户端必须显式处理。③ 可透出异常，指框架或系统产生的且会自行处理的异常，例如 Spring 的 NoSuchRequestHandingMethodException，Spring 会自动完成异常处理，将异常自动映射到合适的状态码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;语言特性-12&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#语言特性-12&quot;&gt;&lt;/a&gt; 语言特性 12&lt;/h3&gt;&lt;h4 id=&quot;q1java-语言的优点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#q1j
      
    
    </summary>
    
    
      <category term="java" scheme="http://vinceshu.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://vinceshu.cn/tags/java/"/>
    
  </entry>
  
</feed>
