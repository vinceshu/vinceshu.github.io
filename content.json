{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://vinceshu.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-07-24T14:13:04.240Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"/404.html","permalink":"http://vinceshu.cn/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-07-24T14:13:04.248Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"books/index.html","permalink":"http://vinceshu.cn/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-25T10:58:32.843Z","updated":"2020-07-25T10:58:32.843Z","comments":false,"path":"about/index.html","permalink":"http://vinceshu.cn/about/index.html","excerpt":"","text":"一个即将步入社会的新人，将从事java开发相关工作，少掉头发，努力搞钱。1234567891011121314151617181920212223&#123; name: 'vinceshu' age: '21', gender: '男', profession: 'Java Developer &amp; Designer', experience: 'null', address: '广东省深圳市', education: '本科', github: 'https://github.com/vinceshu', blog: 'http://vinceshu.gitee.io', email: 'vinceshu@163.com', description: '我只想搞钱', skills: [ ['Java', 'Mysql', 'redis', 'JVM', 'Vue.js', 'Navicat'], ['Spring', 'SpringMvc', 'Mybatis', 'SpringBoot'], ['SpringCloud','Nginx','RabbitMQ','Docker', 'FastDFS'], ['IDEA', 'Maven', 'Git', 'SVN'], ['HTML', 'CSS', 'Jquery', 'Vue,js', 'Thymeleaf'], ['tomcat', 'jetty', 'linux'], ]&#125;"},{"title":"分类","date":"2020-07-24T14:13:04.250Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://vinceshu.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-24T14:13:04.253Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://vinceshu.cn/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-25T09:00:46.006Z","updated":"2019-08-01T11:17:12.000Z","comments":true,"path":"links/index.html","permalink":"http://vinceshu.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-07-24T14:13:04.252Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://vinceshu.cn/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"我的第一篇在阿里云上部署的hexo博文","slug":"我的第一篇在阿里云上部署的hexo博文","date":"2020-07-26T13:38:42.000Z","updated":"2020-07-26T13:38:42.775Z","comments":true,"path":"2020/07/26/我的第一篇在阿里云上部署的hexo博文/","link":"","permalink":"http://vinceshu.cn/2020/07/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%9A%84hexo%E5%8D%9A%E6%96%87/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"1、单元测试&反射&注解","slug":"1、单元测试&反射&注解","date":"2020-07-26T09:48:35.172Z","updated":"2020-07-26T09:49:24.507Z","comments":true,"path":"2020/07/26/1、单元测试&反射&注解/","link":"","permalink":"http://vinceshu.cn/2020/07/26/1%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&%E5%8F%8D%E5%B0%84&%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Junit单元测试12345678910111213141516171819202122232425262728293031* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行 反射：框架设计的灵魂123456* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码字节码文件里面放了：成员变量、、成员方法、构造方法* 反射：将类的各个组成部分封装为其他对象，这就是反射机制 * 好处： 1. 可以在程序运行过程中，操作这些对象。 2. 可以解耦，提高程序的可扩展性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546*Java反射机制提供的功能 -在运行时判断任意一个对象所属的类 -在运行时构造任意一个类的对象 -在运行时判断任意一个类所具有的成员变量和方法 -在运行时获取泛型信息 -在运行时调用任意一个对象的成员变量和方法 -在运行时处理注解 -生成动态代理*主要API -java.lang.Class：代表一个类 -java.lang.reflect.Nethod：代表类的方法 -java.lang.reflect.Field：代表类的成员变量 -java.lang.reflect.Constructor：代表类的构造器 #关于java.lang.Class类的理解： 1、类加载的过程---Java万事万物皆对象 当程序经过javac.exe(编译)命令后，会生成一个或多个字节码文件(.class文件)，接着我们使用java.exe(解释命令)对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载。加载到内存中的类我们就称为运行时类，此运行时类就作为Class类的一个实例化对象。Class clazz = Person.class 2、换句话说，一个Class的实例化对象就对应着一个运行时类 3、加载到内存中的运行时类，会在缓存区缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类 4、哪些类型可以有Class对象？ 1、class：外部类、成员内部类、静态内部类、局部内部类、匿名内部类 2、interface：接口 3、[]：数组 4、enum：枚举 5、annotation：注解@interface 6、primitive type：基本数据类型 7、void #类的加载过程：了解 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤对该类进行初始化 1、类的加载(Load)：将类的class文件读入内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成 ---加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。 2、类的链接(Link)：将类的二进制数据合并到JRE中 ---链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 *验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题 *准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 *解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 3、类的初始化(Initialize)：JVM负责对类进行初始化 *执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 *当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。 *虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。 #类加载器 类加载器的作用： *类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 *类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。12345678910111213141516* 获取Class对象的方式：-----当加载类时会自动创建反射对象，以下是获得反射对象的三种方式 1. Class.forName(\"全类名\")：将字节码文件加载进内存，返回Class对象 ------source源代码阶段，即编译阶段 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 ------Class类对象阶段，即使用类加载器加载字节码文件成为Class类对象阶段 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 ------运行时阶段，即开辟内存空间开始调用main方法阶段 * 多用于对象的获取字节码的方式 4. ClassLoader classLoader = Test.class.getClassLoader(); Class clazz = classLoader.loadClass(\"全类名\"); *通过类加载器的方式获取Class对象（了解） * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。12345678910111213141516171819202122* Class对象功能： * 获取功能：获取当前运行时类中的东西 1. 获取成员变量们 * Field[] getFields() 获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName()1234567891011121314* Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 参数1：哪个对象的属性 参数2：属性值 2. 获取值 * get(Object obj) 参数1：获取哪个对象的属性值 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射* Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) 参数1：方法的调用者 参数2：给方法的形参赋值 * 获取方法名称： * String getName:获取方法名1234* Constructor:构造方法---只有构造器才能获取对象 * 创建对象： * T newInstance(Object... initargs) 参数：指明构造器的参数列表 * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 注解123456789101112* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述： * JDK1.5之后的新特性 * 说明程序的 * 使用注解：@注解名称* 作用分类： ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】12345678910111213141516171819202122232425262728293031323334353637383940* JDK中预定义的一些注解 * @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 * @Deprecated：该注解标注的内容，表示已过时 * @SuppressWarnings：压制警告 * 一般传递参数all @SuppressWarnings(\"all\")* 自定义注解 * 格式： 元注解 public @interface 注解名称&#123; 属性列表; &#125; * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; * 属性：接口中的抽象方法 * 要求： 1. 属性的返回值类型有下列取值 * 基本数据类型 * String * 枚举 * 注解 * 以上类型的数组 2. 定义了属性，在使用时需要给属性赋值 1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略 * 元注解：用于描述注解的注解 * @Target：描述注解能够作用的位置 * ElementType取值： * TYPE：可以作用于类上 * METHOD：可以作用于方法上 * FIELD：可以作用于成员变量上 * @Retention：描述注解被保留的阶段 * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 * @Documented：描述注解是否被抽取到api文档中 * @Inherited：描述注解是否被子类继承123456789101112131415* 在程序使用(解析)注解：获取注解中定义的属性值 1. 获取注解定义的位置的对象 （Class，Method,Field） 2. 获取指定的注解 * getAnnotation(Class) //其实就是在内存中生成了一个该注解接口的子类实现对象 public class ProImpl implements Pro&#123; public String className()&#123; return \"cn.itcast.annotation.Demo1\"; &#125; public String methodName()&#123; return \"show\"; &#125; &#125; 3. 调用注解中的抽象方法获取配置的属性值123456* 小结： 1. 以后大多数时候，我们会使用注解，而不是自定义注解 2. 注解给谁用？ 1. 编译器 2. 给解析程序用 3. 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[],"tags":[]},{"title":"java基础-第二天","slug":"java-two","date":"2020-07-24T14:54:02.696Z","updated":"2020-07-24T11:27:17.100Z","comments":true,"path":"2020/07/24/java-two/","link":"","permalink":"http://vinceshu.cn/2020/07/24/java-two/","excerpt":"","text":"1，JVM,JRE,JDK的作用与区别；jvm也就是我们常说的虚拟机，他是java跨平台的的核心部分，java源程序可以编译为class文件，可以在java虚拟机上执行，所以说java是通过虚拟机与操作系统交互。JRE是java runtime enviroment运行时环境，他包括jvm虚拟机，库函数，还有一些运行程序必需的文件JDK是java开发工具包，包含jre，以及增加编译器和调试器等程序开发文件。 2，Java中8种基本数据类型有哪些，它们占用的字节数分别是多少；int4short2long8byte1char2double8float4boolean1或4 3，接口与抽象类的区别；不同点：1，接口是对类的行为的抽象，抽象类是对一些类的共有属性的抽取。2，接口是用interface定义，抽象类是用abstract定义3，接口没有构造方法，抽象方法可以有构造方法4，接口可以通过多实现来实现多继承，抽象类只能单继承相同点：1，他们不能创建对象，他们只能通过继承或实现他们的类来实例化2，继承和实现了他们的类必须实现他们的抽象方法 4，创建线程有几种方法，它们的优缺点分别是什么；1.继承Thread类 2.实现Runnable接口3.实现Callable接口 4.线程池方式优缺点1.继承Thread类优点 、代码简单 。 缺点 、该类无法继承别的类。2.实现Runnable接口优点 、继承其他类。 同一实现该接口的实例可以共享资源。缺点 、代码复杂，不能抛出异常3.实现Callable优点 、可以获得异步任务的返回值4.线程池 、实现自动化装配，易于管理，循环利用资源。 5，.加载类的方式有哪些；类加载分为静态加载和动态加载，动态加载就是从外储存器加载类，静态加载本质上是从内存中创建类的实例对象，此时类已经被加载到内存中。1，由new关键字创建2，Class.forName(全限定性类名)3，ClassLoader.LoadClass(“类名”)第一种是静态加载，后两种是动态加载前两种是用当前类加载器，后一种是自定义类加载器 6，class.forName加载类与classloader加载类有什么区别；Class的装载包括3个步骤：加载（loading）,连接（link）,初始化（initialize）.Class.forName(className)实际上是调用Class.forName(className, true, this.getClass().getClassLoader())。第二个参数，是指Class被loading后是不是必须被初始化，也就是静态属性，代码块的执行。ClassLoader.loadClass(className)实际上调用的是ClassLoader.loadClass(name, false)，第二个参数指Class是否被link。Class.forName(className)装载的class已经被初始化，而ClassLoader.loadClass(className)装载的class还没有被link。一般情况下，这两个方法效果一样，都能装载Class。但如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。 7，说一下进程与线程的区别；1，进程是资源分配的最小单位，线程是程序执行的最小单位2，进程有独立的代码和数据空间，进程切换会有较大的开销，同一类线程有共同的代码和数据空间，线程切换开销不大。3，系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存4，在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）5，一个程序至少有一个进程；一个进程至少有一个线程","categories":[{"name":"java","slug":"java","permalink":"http://vinceshu.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://vinceshu.cn/tags/java/"}]},{"title":"java基础-第一天","slug":"java-one","date":"2020-07-21T08:56:18.000Z","updated":"2020-07-24T11:27:13.158Z","comments":true,"path":"2020/07/21/java-one/","link":"","permalink":"http://vinceshu.cn/2020/07/21/java-one/","excerpt":"","text":"语言特性 12 Q1：Java 语言的优点？① 平台无关性，摆脱硬件束缚，“一次编写，到处运行”。② 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。③ 热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能。④ 完善的应用程序接口，支持第三方类库。 Q2：Java 如何实现平台无关？JVM： Java 编译器可生成与计算机体系结构无关的字节码指令，字节码文件不仅可以轻易地在任何机器上解释执行，还可以动态地转换成本地机器代码，转换是由 JVM 实现的，JVM 是平台相关的，屏蔽了不同操作系统的差异。语言规范： 基本数据类型大小有明确规定，例如 int 永远为 32 位，而 C/C++ 中可能是 16 位、32 位，也可能是编译器开发商指定的其他大小。Java 中数值类型有固定字节数，二进制数据以固定格式存储和传输，字符串采用标准的 Unicode 格式存储。 Q3：JDK 和 JRE 的区别？JDK： Java Development Kit，开发工具包。提供了编译运行 Java 程序的各种工具，包括编译器、JRE 及常用类库，是 JAVA 核心。JRE： Java Runtime Environment，运行时环境，运行 Java 程序的必要环境，包括 JVM、核心类库、核心配置工具。 Q4：Java 按值调用还是引用调用？按值调用指方法接收调用者提供的值，按引用调用指方法接收调用者提供的变量地址。Java 总是按值调用，方法得到的是所有参数值的副本，传递对象时实际上方法接收的是对象引用的副本。方法不能修改基本数据类型的参数，如果传递了一个 int 值 ，改变值不会影响实参，因为改变的是值的一个副本。可以改变对象参数的状态，但不能让对象参数引用一个新的对象。如果传递了一个 int 数组，改变数组的内容会影响实参，而改变这个参数的引用并不会让实参引用新的数组对象。 Q5：浅拷贝和深拷贝的区别？浅拷贝： 只复制当前对象的基本数据类型及引用变量，没有复制引用变量指向的实际对象。修改克隆对象可能影响原对象，不安全。深拷贝： 完全拷贝基本数据类型和引用数据类型，安全。 Q6：什么是反射？在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任意一个对象都能调用它的任意方法和属性，这种动态获取信息及调用对象方法的功能称为反射。缺点是破坏了封装性以及泛型约束。反射是框架的核心，Spring 大量使用反射。 Q7：Class 类的作用？如何获取一个 Class 对象？在程序运行期间，Java 运行时系统为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是 Class，这是一个泛型类。简单来说就是Class是一个保存了运行时信息的一个类，运行信息可以知道每个对象属于哪个类，jvm利用运行时信息选择相应的方法执行。获取 Class 对象：① 类名.class 。②对象的 getClass方法。③ Class.forName(类的全限定名)。 Q8：什么是注解？什么是元注解？注解是一种标记，使类或接口附加额外信息，帮助编译器和 JVM 完成一些特定功能，例如 @Override 标识一个方法是重写方法。元注解是自定义注解的注解，例如：@Target：约束作用位置，值是 ElementType 枚举常量，包括 METHOD 方法、VARIABLE 变量、TYPE 类/接口、PARAMETER 方法参数、CONSTRUCTORS 构造方法和 LOACL_VARIABLE 局部变量等。@Rentention：约束生命周期，值是 RetentionPolicy 枚举常量，包括 SOURCE 源码、CLASS 字节码和 RUNTIME 运行时。@Documented：表明这个注解应该被 javadoc 记录。 Q9：什么是泛型，有什么作用？泛型本质是参数化类型，解决不确定对象具体类型的问题。泛型在定义处只具备执行 Object 方法的能力。泛型的好处：① 类型安全，放置什么出来就是什么，不存在 ClassCastException。② 提升可读性，编码阶段就显式知道泛型集合、泛型方法等处理的对象类型。③ 代码重用，合并了同类型的处理代码。 Q10：泛型擦除是什么？泛型用于编译阶段，编译后的字节码文件不包含泛型类型信息，因为虚拟机没有泛型类型对象，所有对象都属于普通类。例如定义 List 或 List，在编译后都会变成 List 。定义一个泛型类型，会自动提供一个对应原始类型，类型变量会被擦除。如果没有限定类型就会替换为 Object，如果有限定类型就会替换为第一个限定类型，例如 `` 会使用 A 类型替换 T。 Q11：JDK8 新特性有哪些？**lambda 表达式：**允许把函数作为参数传递到方法，简化匿名内部类代码。**函数式接口：**使用 @FunctionalInterface 标识，有且仅有一个抽象方法，可被隐式转换为 lambda 表达式。**方法引用：**可以引用已有类或对象的方法和构造方法，进一步简化 lambda 表达式。**接口：**接口可以定义 default 修饰的默认方法，降低了接口升级的复杂性，还可以定义静态方法。**注解：**引入重复注解机制，相同注解在同地方可以声明多次。注解作用范围也进行了扩展，可作用于局部变量、泛型、方法异常等。**类型推测：**加强了类型推测机制，使代码更加简洁。**Optional 类：**处理空指针异常，提高代码可读性。**Stream 类：**引入函数式编程风格，提供了很多功能，使代码更加简洁。方法包括 forEach 遍历、count 统计个数、filter 按条件过滤、limit 取前 n 个元素、skip 跳过前 n 个元素、map 映射加工、concat 合并 stream 流等。**日期：**增强了日期和时间 API，新的 java.time 包主要包含了处理日期、时间、日期/时间、时区、时刻和时钟等操作。**JavaScript：**提供了一个新的 JavaScript 引擎，允许在 JVM上运行特定 JavaScript 应用。 Q12：异常有哪些分类？所有异常都是 Throwable 的子类，分为 Error 和 Exception。Error 是 Java 运行时系统的内部错误和资源耗尽错误，例如 StackOverFlowError 和 OutOfMemoryError，这种异常程序无法处理。Exception 分为受检异常和非受检异常，受检异常需要在代码中显式处理，否则会编译出错，非受检异常是运行时异常，继承自 RuntimeException。受检异常：① 无能为力型，如字段超长导致的 SQLException。② 力所能及型，如未授权异常 UnAuthorizedException，程序可跳转权限申请页面。常见受检异常还有 FileNotFoundException、ClassNotFoundException、IOException等。非受检异常：① 可预测异常，例如 IndexOutOfBoundsException、NullPointerException、ClassCastException 等，这类异常应该提前处理。② 需捕捉异常，例如进行 RPC 调用时的远程服务超时，这类异常客户端必须显式处理。③ 可透出异常，指框架或系统产生的且会自行处理的异常，例如 Spring 的 NoSuchRequestHandingMethodException，Spring 会自动完成异常处理，将异常自动映射到合适的状态码。","categories":[{"name":"java","slug":"java","permalink":"http://vinceshu.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://vinceshu.cn/tags/java/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://vinceshu.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://vinceshu.cn/tags/java/"}]}